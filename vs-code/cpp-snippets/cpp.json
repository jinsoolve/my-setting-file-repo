{
  "ps": {
    "prefix": "ps",
    "description": "c++ code template for Problem Solving",
    "body": [
      "#include <bits/stdc++.h>",
      "",
      "#define endl \"\\n\"",
      "#define all(v) (v).begin(), (v).end()",
      "#define all1(v) (v).begin()+1, (v).end()",
      "#define For(i, a, b) for(int i=(a); i<(b); i++)",
      "#define FOR(i, a, b) for(int i=(a); i<=(b); i++)",
      "#define Bor(i, a, b) for(int i=(a)-1; i>=(b); i--)",
      "#define BOR(i, a, b) for(int i=(a); i>=(b); i--)",
      "#define ft first",
      "#define sd second",
      "",
      "using namespace std;",
      "using ll = long long;",
      "using lll = __int128_t;",
      "using ulll = __uint128_t;",
      "using ull = unsigned long long;",
      "using ld = long double;",
      "using pii = pair<int, int>;",
      "using pll = pair<ll, ll>;",
      "using ti3 = tuple<int, int, int>;",
      "using tl3 = tuple<ll, ll, ll>;",
      "",
      "template<typename T> using ve = vector<T>;",
      "template<typename T> using vve = vector<vector<T>>;",
      "",
      "template<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }",
      "template<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }",
      "",
      "const int INF = 987654321;",
      "const int INF0 = numeric_limits<int>::max();",
      "const ll LNF = 987654321987654321;",
      "const ll LNF0 = numeric_limits<ll>::max();",
      "",
      "class Solution {",
      "private:",
      "",
      "public:",
      "    Solution() = default;",
      "    ~Solution() = default;",
      "    void init() {",
      "        ",
      "    }",
      "    void solve() {",
      "        init();",
      "        ",
      "        ",
      "    }",
      "};",
      "",
      "int main(void) {",
      "    ios_base::sync_with_stdio(false);",
      "    cin.tie(nullptr);",
      "    cout.tie(nullptr);",
      "",
      "    int TC=1;",
      "//    cin >> TC;",
      "    FOR(tc, 1, TC) {",
      "//        cout << \"Case #\" << tc << \": \";",
      "        Solution solution;",
      "        solution.solve();",
      "    }",
      "",
      "    return 0;",
      "}"
    ]
  },
  "cpp.bimatch": {
    "prefix": "cpp.bimatch",
    "description": "Bipartite Matching",
    "body": [
      "class BipartiteMatching {",
      "private:",
      "    int ln, rn; // (1~ln) -> (1~rn) bipartite graph",
      "    vector<vector<int>> g; // g[1~ln]",
      "    vector<bool> visited; // visited[1~ln]",
      "    vector<int> parent; // parent[1~rn]",
      "",
      "public:",
      "    BipartiteMatching() {}",
      "    BipartiteMatching(int _ln, int _rn) : ln(_ln), rn(_rn), g(_ln+1), visited(_ln+1), parent(_rn+1) {}",
      "    ~BipartiteMatching() { this->clear(); }",
      "    void clear() {",
      "        for(int i=1; i<=ln; i++) g[i].clear();",
      "    }",
      "    void add_edge(int u, int v) { g[u].emplace_back(v); }",
      "    bool dfs(int here) {",
      "        // 이미 처리한 노드는 더 이상 볼 필요가 없음",
      "        if(visited[here]) return false;",
      "        visited[here] = true;",
      "",
      "        // 연결된 모든 노드에 대해서 들어갈 수 있는지 시도",
      "        for(int there : g[here]) {",
      "            if(parent[there] == -1 || dfs(parent[there])) {",
      "                parent[there] = here;",
      "                return true;",
      "            }",
      "        }",
      "        return false;",
      "    }",
      "    int matching() {",
      "        fill(all(parent), -1);",
      "        int ret = 0;",
      "        for(int i=1; i<=ln; i++) {",
      "            fill(all(visited), false);",
      "            ret += dfs(i);",
      "        }",
      "        return ret;",
      "    }",
      "};"
    ]
  },
  "cpp.comb": {
    "prefix": "cpp.comb",
    "description": "Combination",
    "body": [
      "const ll mod = 998244353;",
      "",
      "ve<ll> facto(mxn, -1);",
      "ll Facto(ll n) {",
      "    if(n <= 1) return 1;",
      "    ll &ret = facto[n];",
      "    if(ret != -1) return ret;",
      "    return ret = (n * Facto(n-1)) % mod;",
      "}",
      "// a^b mod c  ",
      "ll Pow(ll a, ll b, ll c = mod) {",
      "    ll res = 1;",
      "    while(b) {",
      "        if(b%2) res = (res * a) % c;",
      "        a = (a * a) % c;",
      "        b >>= 1;",
      "    }",
      "    return res;",
      "}",
      "ll comb(ll n, ll k, ll p = mod) {",
      "    ll res = (Facto(n) * Pow((Facto(k)*Facto(n-k))%p, p-2))%p;",
      "//    cout << res << endl;  ",
      "    return res;",
      "}"
    ]
  },
  "cpp.gcd": {
    "prefix": "cpp.gcd",
    "description": "GCD",
    "body": [
      "ll gcd(ll a, ll b) {",
      "    if(b == 0) return a;",
      "    return gcd(b, a%b);",
      "}"
    ]
  },
  "cpp.kmp": {
    "prefix": "cpp.kmp",
    "description": "KMP Algoritnm",
    "body": [
      "vector<int> getPi(string p){",
      "    int m = (int)p.size(), j=0;",
      "    vector<int> pi(m, 0);",
      "    for(int i=1; i<m; i++){",
      "        while(j > 0 && p[i] !=  p[j])",
      "            j = pi[j-1];",
      "        if(p[i] == p[j])",
      "            pi[i] = ++j;",
      "    }",
      "    return pi;",
      "}",
      "vector<int> kmp(string s, string p){",
      "    vector<int> ans;",
      "    auto pi = getPi(p);",
      "    int n = s.size(), m = p.size(), j = 0;",
      "    for(int i=0; i<n; i++){",
      "        while(j>0 && s[i] != p[j]) j = pi[j-1];",
      "        if(s[i] == p[j]){",
      "            if(j==m-1){",
      "                ans.push_back(i-m+1);",
      "                j = pi[j];",
      "            }else{",
      "                j++;",
      "            }",
      "        }",
      "    }",
      "    return ans;",
      "}"
    ]
  },
  "cpp.lazysegment": {
    "prefix": "cpp.lazysegment",
    "description": "lazy segment",
    "body": [
      "struct Lazy {",
      "    ll val, a, b; // a * val + b",
      "};",
      "",
      "class LazySegment {",
      "public:",
      "    vector<Lazy> tree; //tree[node] := a[start ~ end] 의 합",
      "",
      "    LazySegment() {}",
      "    LazySegment(int size) {",
      "        this->resize(size);",
      "    }",
      "    void resize(int size) {",
      "        size = (int) floor(log2(size)) + 2;",
      "        size = pow(2, size);",
      "        tree.resize(size, {0,1, 0});",
      "    }",
      "    ll init(vector<ll> &a, int node, int start, int end) {",
      "        if(start == end) return tree[node].val = a[start];",
      "        return tree[node].val = (init(a, 2*node, start, (start+end)/2) + init(a, 2*node+1, (start+end)/2+1, end));",
      "    }",
      "    void update_lazy(int node, int start, int end) {",
      "        if(tree[node].a == 1 && tree[node].b == 0) return;",
      "        tree[node].val = (tree[node].a*tree[node].val + tree[node].b*(end-start+1));",
      "        if(start != end) {",
      "            for(auto i : {2*node, 2*node+1}) {",
      "                tree[i].a = (tree[node].a * tree[i].a);",
      "                tree[i].b = (tree[node].a * tree[i].b + tree[node].b);",
      "            }",
      "        }",
      "        tree[node].a = 1, tree[node].b = 0;",
      "    }",
      "    void update(int node, int start, int end, int left, int right, ll a, ll b) {",
      "        update_lazy(node, start, end);",
      "        if(right < start || end < left) return;",
      "        if(left <= start && end <= right) {",
      "            tree[node].a = (tree[node].a * a);",
      "            tree[node].b = (tree[node].b + b);",
      "            update_lazy(node, start, end);",
      "            return;",
      "        }",
      "        update(node * 2, start, (start + end) / 2, left, right, a, b);",
      "        update(node * 2 + 1, (start + end) / 2 + 1, end, left, right, a, b);",
      "        tree[node].val = (tree[2*node].val + tree[2*node+1].val);",
      "    }",
      "    ll sum(int node, int start, int end, int left, int right) {",
      "        update_lazy(node, start, end);",
      "        if(right < start || end < left) return 0;",
      "        if(left <= start && end <= right) return tree[node].val;",
      "        return (sum(node * 2, start, (start + end) / 2, left, right) +",
      "                sum(node * 2 + 1, (start + end) / 2 + 1, end, left, right));",
      "    }",
      "};"
    ]
  },
  "cpp.lca": {
    "prefix": "cpp.lca",
    "description": "LCA",
    "body": [
      "class Lowest_Common_Ancestor {",
      "private:",
      "    int LOG_MXN;",
      "    int N;",
      "    vector<vector<int>> g, parent;",
      "    vector<int> depth;",
      "",
      "    void make_tree(int u, int lv=1) {",
      "        depth[u] = lv;",
      "        for(int v : g[u]) {",
      "            if(depth[v] != -1) continue;",
      "            parent[v][0] = u;",
      "            make_tree(v,lv+1);",
      "        }",
      "    }",
      "    void link_ancestor() {",
      "        for(int i=1; i<=LOG_MXN; i++)",
      "            for(int here=1; here<=N; here++)",
      "                parent[here][i] = parent[parent[here][i-1]][i-1];",
      "    }",
      "public:",
      "    Lowest_Common_Ancestor() {}",
      "    Lowest_Common_Ancestor(int _N) : N(_N), g(_N+1), depth(_N+1, -1) {",
      "        LOG_MXN = ceil(log2(N)) + 2;",
      "        parent = vector<vector<int>>(N+1, vector<int>(LOG_MXN + 1, 0));",
      "    }",
      "    void add_edge(int u, int v) {",
      "        g[u].emplace_back(v);",
      "        g[v].emplace_back(u);",
      "    }",
      "    void init(int root) {",
      "        make_tree(root);",
      "        link_ancestor();",
      "    }",
      "    int find_lca(int a, int b) {",
      "        if(depth[a] > depth[b]) swap(a,b);",
      "",
      "        for(int i=LOG_MXN; i>=0; i--) {",
      "            if(depth[parent[b][i]] < depth[a]) continue;",
      "            b = parent[b][i];",
      "        }",
      "        if(a == b) return a;",
      "",
      "        for(int i=LOG_MXN; i>=0; i--) {",
      "            if(parent[a][i] == parent[b][i]) continue;",
      "            a = parent[a][i], b = parent[b][i];",
      "        }",
      "        return parent[a][0];",
      "    }",
      "};"
    ]
  },
  "cpp.matrix": {
    "prefix": "cpp.matrix",
    "description": "Matrix Class",
    "body": [
      "const int mod;",
      "",
      "class matrix {",
      "public:",
      "    int r, c;",
      "    ll **item;",
      "",
      "    matrix(int r, int c) {",
      "        this->r = r;",
      "        this->c = c;",
      "        item = new ll *[r];",
      "        for (int i = 0; i < r; i++) {",
      "            item[i] = new ll[c];",
      "            for (int j = 0; j < c; j++) {",
      "                item[i][j] = 0;",
      "            }",
      "        }",
      "    }",
      "    ~matrix() {",
      "        delete[]item;",
      "    }",
      "",
      "    void iden() {",
      "        if(r != c) exit(-1);",
      "        for (int i = 0; i < r; i++) {",
      "            for (int j = 0; j < c; j++) {",
      "                if(i==j) item[i][j] = 1;",
      "                else item[i][j] = 0;",
      "            }",
      "        }",
      "    }",
      "    matrix& operator =(const matrix& cp) {",
      "        if(!(r == cp.r && c == cp.c)) exit(-1);",
      "        for (int i = 0; i < r; i++) {",
      "            for (int j = 0; j < c; j++) {",
      "                item[i][j] = cp.item[i][j];",
      "            }",
      "        }",
      "        return *this;",
      "    }",
      "    matrix operator *(const matrix& cp) const {",
      "        if(c != cp.r) exit(-1);",
      "        matrix mat(r, cp.c);",
      "        for (int i = 0; i < mat.r; i++) {",
      "            for (int j = 0; j < mat.c; j++) {",
      "                for (int k = 0; k < c; k++) {",
      "                    mat.item[i][j] = (mat.item[i][j] + item[i][k] * cp.item[k][j]) % mod;",
      "                }",
      "            }",
      "        }",
      "        return mat;",
      "    }",
      "    matrix& operator *=(const matrix &cp) {",
      "        if(c != cp.r) exit(-1);",
      "        (*this) = (*this) * cp;",
      "        return *this;",
      "    }",
      "    void exp(ll times) {",
      "        matrix a(r, c);",
      "        a = *this;",
      "        (*this).iden();",
      "",
      "        while(times) {",
      "            if(times%2) *this *= a;",
      "            a *= a;",
      "            times /= 2;",
      "        }",
      "    }",
      "    void print() {",
      "        for (int i = 0; i < r; i++) {",
      "            for (int j = 0; j < c; j++) {",
      "                cout << item[i][j] << ' ';",
      "            }",
      "            cout << '\\n';",
      "        }",
      "    }",
      "};"
    ]
  },
  "cpp.mergetree": {
    "prefix": "cpp.mergetree",
    "description": "Merge Tree",
    "body": [
      "class mergeTree {",
      "public:",
      "    vector<vector<ll>> tree; //tree[node] := a[start ~ end] 의 합",
      "",
      "    mergeTree() {}",
      "    mergeTree(int size) {",
      "        this->resize(size);",
      "    }",
      "    void resize(int size) {",
      "        size = (int) floor(log2(size)) + 2;",
      "        size = pow(2, size);",
      "        tree.resize(size);",
      "    }",
      "",
      "    void update(int node, int start, int end, int index, ll value) {",
      "        if(index < start || end < index) return;",
      "        tree[node].emplace_back(value);",
      "        if(start != end) {",
      "            update(node * 2, start, (start + end) / 2, index, value);",
      "            update(node * 2 + 1, (start + end) / 2 + 1, end, index, value);",
      "        }",
      "    }",
      "    ll query(int node, int start, int end, int left, int right, ll value) {",
      "        if(right < start || end < left) return 0;",
      "        if(left <= start && end <= right) return tree[node].end() - upper_bound(all(tree[node]), value);",
      "        return query(node * 2, start, (start + end) / 2, left, right, value) +",
      "        query(node * 2 + 1, (start + end) / 2 + 1, end, left, right, value);",
      "    }",
      "};",
      ""
    ]
  },
  "cpp.mcmf": {
    "prefix": "cpp.mcmf",
    "description": "MinCost MaxFlow",
    "body": [
      "template <class T> struct MinCost_MaxFlow {",
      "    int N;",
      "    struct Edge {",
      "        int to, rev;",
      "        T cap, cost;",
      "    };",
      "    vector<vector<Edge>> g; // adjacent list",
      "    vector<T> dist; // min dist(cost) from source",
      "    vector<int> pv, pe; // prev's vertex and edge number",
      "    vector<bool> inQ; // is it in queue?",
      "",
      "    MinCost_MaxFlow(int _N) : N(_N), g(_N), dist(_N, 0), pv(_N), pe(_N), inQ(_N, false) {}",
      "",
      "    void clear() {",
      "        for(int i=0; i<N; i++) g[i].clear();",
      "    }",
      "",
      "    void add_edge(int u, int v, T cap, T cost) {",
      "        int u_idx = g[u].size();",
      "        int v_idx = g[v].size();",
      "        if(u == v) v_idx++;",
      "        g[u].emplace_back(Edge{v, v_idx, cap, cost});",
      "        g[v].emplace_back(Edge{u, u_idx, (T)0, -cost});",
      "    }",
      "    bool SPFA(int src, int sink) {",
      "        dist = vector<T>(N, numeric_limits<T>::max());",
      "        inQ = vector<bool>(N, false);",
      "        queue<int> q;",
      "",
      "        dist[src] = 0; inQ[src] = true;",
      "        q.push(src);",
      "        while(!q.empty()) {",
      "            int here = q.front(); q.pop();",
      "            inQ[here] = false;",
      "            for(int i=0; i<g[here].size(); i++) {",
      "                Edge edge = g[here][i];",
      "                int there = edge.to;",
      "                if(edge.cap>0 && dist[there] > dist[here] + edge.cost) {",
      "                    dist[there] = dist[here] + edge.cost;",
      "                    pv[there] = here; pe[there] = i;",
      "                    if(!inQ[there]) inQ[there] = true, q.push(there);",
      "                }",
      "            }",
      "        }",
      "",
      "        return dist[sink] != numeric_limits<T>::max();",
      "    }",
      "",
      "    pair<T,T> MCMF(int src, int sink) {",
      "        T min_cost = 0, max_flow = 0;",
      "        while(SPFA(src, sink)) {",
      "            T flow = numeric_limits<T>::max();",
      "            for(int pos=sink; pos!=src; pos=pv[pos])",
      "                flow = min(flow, g[pv[pos]][pe[pos]].cap);",
      "            min_cost += dist[sink] * flow;",
      "            max_flow += flow;",
      "            for(int pos=sink; pos!=src; pos=pv[pos]) {",
      "                int rev = g[pv[pos]][pe[pos]].rev;",
      "                g[pv[pos]][pe[pos]].cap -= flow;",
      "                g[pos][rev].cap += flow;",
      "            }",
      "        }",
      "        return {min_cost, max_flow};",
      "    }",
      "};"
    ]
  },
  "cpp.nim": {
    "prefix": "cpp.nim",
    "description": "Nim Game",
    "body": [
      "class NIM_Game {",
      "private:",
      "    int N;",
      "    vector<int> stones;",
      "",
      "    int nim_sum() {",
      "        int ret = 0;",
      "        for(int stone : stones)",
      "            ret ^= stone;",
      "        return ret;",
      "    }",
      "    int get_one_stone_cnt() {",
      "        int ret = 0;",
      "        for(int stone : stones) {",
      "            ret += (stone == 1);",
      "        }",
      "        return ret;",
      "    }",
      "public:",
      "    NIM_Game(vector<int> &_stones) : N(_stones.size()), stones(_stones) {}",
      "",
      "    // true: 선공 승리, false: 후공 승리",
      "    bool final_stone_victory() {",
      "        return nim_sum() != 0;",
      "    }",
      "    // true: 선공 승리, false: 후공 승리",
      "    bool final_stone_defeat() {",
      "        int oneStoneCnt = get_one_stone_cnt();",
      "        if(oneStoneCnt == 0) return nim_sum() != 0; // 돌이 1개인 더미가 없는 경우",
      "        if(oneStoneCnt == N) return nim_sum() == 0; // 모든 돌더미가 돌이 1개인 더미인 경우",
      "        if(oneStoneCnt%2 == 0) { // 돌이 1개인 더미가 짝수 개인 경우, 1개가 아닌 더미를 1개로 만들어서 oneStoneCnt를 홀수개로 만든다.",
      "            for (int i = 0; i < N; i++)",
      "                if (stones[i] != 1) { stones[i] = 1; break; }",
      "        }",
      "        return nim_sum() != 0;",
      "    }",
      "};"
    ]
  },
  "cpp.point": {
    "prefix": "cpp.point",
    "description": "Point Class",
    "body": [
      "struct Point {",
      "    ll x, y;",
      "",
      "    Point() {}",
      "    Point(ll _x, ll _y) : x(_x), y(_y) {}",
      "    ll cross(Point other) {",
      "        return x*other.y - y*other.x;",
      "    }",
      "    ll crossSign(Point other) {",
      "        ll res = this->cross(other);",
      "        if(res > 0) return 1;",
      "        else if(res < 0) return -1;",
      "        return 0;",
      "    }",
      "    ll dist(Point other) {",
      "        return pow(x-other.x,2) + pow(y-other.y,2);",
      "    }",
      "    Point operator-(Point other) const {",
      "        return Point(x-other.x, y-other.y);",
      "    }",
      "    bool operator==(Point other) const {",
      "        return x == other.x && y == other.y;",
      "    }",
      "    bool operator<(Point other) const {",
      "        if(x == other.x) return y < other.y;",
      "        return x < other.x;",
      "    }",
      "    void print() {",
      "        cout << x << ' ' << y << ' ';",
      "    }",
      "};",
      "",
      "ll n;",
      "Point reference;",
      "",
      "vector<Point> Graham_Scan(vector<Point> &points) {",
      "    sort(all(points)); points.erase(unique(all(points)), points.end());",
      "    reference = points[0];",
      "    auto cmp = [&](Point a, Point b) {",
      "        ll res = (a - reference).cross(b - reference);",
      "        if(res != 0) return res > 0;",
      "        return reference.dist(a) < reference.dist(b);",
      "    };",
      "    sort(points.begin()+1, points.end(), cmp);",
      "",
      "    vector<Point> convex;",
      "    for(Point p3 : points) {",
      "        while(convex.size() >= 2) {",
      "            Point p2 = convex.back();",
      "            Point p1 = convex[convex.size() - 2];",
      "            ll ccw = (p2-p1).cross(p3-p2);",
      "            if(ccw > 0) break;",
      "            convex.pop_back();",
      "        }",
      "        convex.emplace_back(p3);",
      "    }",
      "    return convex;",
      "}",
      "ll Rotating_Calipers(vector<Point> &convex) {",
      "    int sz = convex.size();",
      "    int l=0, r=0;",
      "    for(int k=0; k<sz; k++) {",
      "        if(convex[l].x > convex[k].x) l = k;",
      "        if(convex[r].x < convex[k].x) r = k;",
      "    }",
      "",
      "    ll ret = convex[l].dist(convex[r]);",
      "    for(int _=0; _<sz; _++) {",
      "        int nl = (l+1)%sz, nr = (r+1)%sz;",
      "        ll ccw = (convex[nl] - convex[l]).crossSign(convex[nr] - convex[r]);",
      "        if(ccw < 0) l = (l+1)%sz;",
      "        else r = (r+1)%sz;",
      "        ll res = convex[l].dist(convex[r]);",
      "        ret = max(ret, res);",
      "    }",
      "    return ret;",
      "}"
    ]
  },
  "cpp.scc": {
    "prefix": "cpp.scc",
    "description": "SCC(Strongly Connected Components)",
    "body": [
      "class SCC {",
      "private:",
      "    int _id, _scc;",
      "    vector<int> id; // id[x] := x번 노드의 방문 순서(고유번호)",
      "    stack<int> st;",
      "",
      "    int dfs(int u) {",
      "        id[u] = _id++; // 방문한 순서를 의미",
      "        st.push(u);",
      "",
      "        int parent = id[u];",
      "        for(int v : g[u]) {",
      "            if(id[v] == -1) parent = min(parent, dfs(v));",
      "            else if(scc[v] == -1) parent = min(parent, id[v]);",
      "        }",
      "",
      "        if(parent == id[u]) {",
      "            while(true) {",
      "                int t = st.top(); st.pop();",
      "                scc[t] = _scc;",
      "                sccSize[_scc]++;",
      "                if(t == u) break;",
      "            }",
      "            _scc++;",
      "        }",
      "",
      "        // 가장 먼저 방문한 순서를 반환.",
      "        return parent;",
      "    }",
      "",
      "public:",
      "    int N;",
      "",
      "    // scc[x] := x번 노드의 scc 번호",
      "    // sccSize[scc_x] := scc_x번의 scc의 집합 크기",
      "    vector<int> scc, sccSize;",
      "",
      "    // scc_nodes[scc_num] := scc_num에 속해 있는 노드 번호들",
      "    vector<vector<int>> scc_nodes;",
      "",
      "    // g := 기존 그래프",
      "    // scc_g := scc 끼리의 그래프",
      "    vector<vector<int>> g, scc_g;",
      "",
      "    SCC() = default;",
      "    SCC(int _N) : N(_N), _id(1), _scc(1), id(_N+1, -1), scc(_N+1, -1), sccSize(_N+1,0), g(_N+1), scc_nodes(_N+1) {}",
      "    ~SCC() = default;",
      "",
      "    void add_edge(int u, int v) { g[u].emplace_back(v); }",
      "    void find_scc() {",
      "        for(int i=1; i<=N; i++)",
      "            if(id[i] == -1) dfs(i);",
      "        scc_g.resize(_scc);",
      "        for(int u=1; u<=N; u++) {",
      "            scc_nodes[scc[u]].emplace_back(u);",
      "            for(int v : g[u]) {",
      "                if(scc[u] != scc[v]) scc_g[scc[u]].emplace_back(scc[v]);",
      "            }",
      "        }",
      "    }",
      "};"
    ]
  },
  "cpp.segment": {
    "prefix": "cpp.segment",
    "description": "Segment Tree",
    "body": [
      "class Segment {",
      "public:",
      "    vector<ll> tree; //tree[node] := a[start ~ end] 의 합",
      "",
      "    Segment() {}",
      "    Segment(int size) {",
      "        this->resize(size);",
      "    }",
      "    void resize(int size) {",
      "        size = (int) floor(log2(size)) + 2;",
      "        size = pow(2, size);",
      "        tree.resize(size, 0);",
      "    }",
      "    ll init(vector<ll> &a, int node, int start, int end) {",
      "        if(start == end) return tree[node] = a[start];",
      "        else return tree[node] = init(a, 2 * node, start, (start + end) / 2) +",
      "                                 init(a, 2 * node + 1, (start + end) / 2 + 1, end);",
      "    }",
      "    ll sum(int node, int start, int end, int left, int right) {",
      "        if(right < start || end < left) return 0;",
      "        if(left <= start && end <= right) return tree[node];",
      "        return sum(node * 2, start, (start + end) / 2, left, right) +",
      "               sum(node * 2 + 1, (start + end) / 2 + 1, end, left, right);",
      "    }",
      "    void update(int node, int start, int end, int index, ll value) {",
      "        if(index < start || end < index) return;",
      "        if(start == end) tree[node] = value;",
      "        else {",
      "            update(node * 2, start, (start + end) / 2, index, value);",
      "            update(node * 2 + 1, (start + end) / 2 + 1, end, index, value);",
      "            tree[node] = tree[2*node] + tree[2*node+1];",
      "        }",
      "    }",
      "};"
    ]
  },
  "cpp.sa": {
    "prefix": "cpp.sa",
    "description": "Suffix Array and LCP",
    "body": [
      "class SuffixArray {",
      "private:",
      "    string str;",
      "    vector<int> sa, rank, tmpRank, lcp;",
      "    int sz;",
      "",
      "    void make_sa() {",
      "        sa.assign(sz, 0);",
      "        rank.assign(sz+1, -1);",
      "        tmpRank.assign(sz+1, -1);",
      "",
      "        for(int i=0; i<sz; i++) sa[i] = i, rank[i] = str[i]-'a';",
      "",
      "        for(int cmpLen=1; cmpLen<sz; cmpLen<<=1) {",
      "            auto cmp = [&](int x, int y) {",
      "                if(rank[x] == rank[y]) return rank[x+cmpLen] < rank[y+cmpLen];",
      "                return rank[x] < rank[y];",
      "            };",
      "            sort(all(sa),cmp);",
      "",
      "            tmpRank[sa[0]] = 0;",
      "            for(int i=1; i<sz; i++) {",
      "                if(cmp(sa[i-1],sa[i])) tmpRank[sa[i]] = tmpRank[sa[i-1]] + 1;",
      "                else tmpRank[sa[i]] = tmpRank[sa[i-1]];",
      "            }",
      "            rank = tmpRank;",
      "        }",
      "    }",
      "    void make_lcp() {",
      "        lcp.assign(sz, 0);",
      "        rank.assign(sz, 0);",
      "",
      "        for(int i=0; i<sz; i++) rank[sa[i]] = i;",
      "",
      "        int len = 0;",
      "        for(int i=0; i<sz; i++) {",
      "            if(rank[i] > 0) {",
      "                int j = sa[rank[i]-1];",
      "                while(str[i+len] == str[j+len]) len++;",
      "                lcp[rank[i]] = len;",
      "                if(len > 0) len--;",
      "            }",
      "        }",
      "    }",
      "    void update() { make_sa(); make_lcp(); }",
      "",
      "public:",
      "    SuffixArray(string &s) { this->input_string(s); }",
      "",
      "    void input_string(string &s) {",
      "        str = s; sz = s.size();",
      "        update();",
      "    }",
      "    vector<int> get_sa() { return sa; }",
      "    vector<int> get_lcp() { return lcp; }",
      "};"
    ]
  },
  "cpp.trie": {
    "prefix": "cpp.trie",
    "description": "Trie",
    "body": [
      "const int alphabet = 26;",
      "inline int ctoi(char c) { return (c >= 'a') ? c - 'a' : c - 'A'; }",
      "class Trie {",
      "public:",
      "    bool terminal;",
      "    Trie *child[alphabet];",
      "",
      "    Trie() : terminal(false) {",
      "        memset(child, 0, sizeof child);",
      "    }",
      "    ~Trie() {",
      "        for (int i = 0; i < alphabet; i++) {",
      "            delete child[i];",
      "        }",
      "    }",
      "    void insert(const char* key) {",
      "        if(*key == 0) terminal = true;",
      "        else {",
      "            int next = ctoi(*key);",
      "            if (!child[next]) child[next] = new Trie();",
      "            child[next]->insert(key + 1);",
      "        }",
      "    }",
      "    Trie *find(const char *key) {",
      "        if(*key == 0) return this;",
      "        int next = ctoi(*key);",
      "        if(!child[next]) return nullptr;",
      "        return child[next]->find(key + 1);",
      "    }",
      "};"
    ]
  },
  "cpp.maptrie": {
    "prefix": "cpp.maptrie",
    "description": "Trie by map",
    "body": [
      "class Trie {",
      "public:",
      "    bool terminal;",
      "    unordered_map<char, Trie*> child;",
      "    ",
      "    Trie() : terminal(false) {}",
      "    void insert(const char* key) {",
      "        if(*key == 0) terminal = true;",
      "        else {",
      "            if (!child[*key]) child[*key] = new Trie();",
      "            child[*key]->insert(key + 1);",
      "        }",
      "    }",
      "    Trie *find(const char *key) {",
      "        if(*key == 0) return this;",
      "        if(!child[*key]) return nullptr;",
      "        return child[*key]->find(key + 1);",
      "    }",
      "};"
    ]
  },
  "cpp.precision": {
    "prefix": "cpp.precision",
    "description": "set precision",
    "body": ["cout << fixed << setprecision(10);"]
  },
  "cpp.pow": {
    "prefix": "cpp.pow",
    "description": "pow - exponential by squaring",
    "body": [
      "// a^b mod c",
      "ll myPow(ll a, ll b, ll c = mod) {",
      "    ll res = 1;",
      "    while(b) {",
      "        if(b%2) res = (res * a) % c;",
      "        a = (a * a) % c;",
      "        b >>= 1;",
      "    }",
      "    return res;",
      "}"
    ]
  },
  "cpp.mint": {
    "prefix": "cpp.mint",
    "description": "modular int class",
    "body": [
      "const ll MOD = 1e9 + 7;",
      "",
      "class mint {",
      "private:",
      "    ll value;",
      "    ll mod;",
      "",
      "public:",
      "    mint(ll v = 0, ll m = MOD) : value(v % m), mod(m) {",
      "        if (value < 0)",
      "            value += m;",
      "    }",
      "",
      "    void input() {",
      "        ll x; cin >> x;",
      "        *this =  mint(x);",
      "    }",
      "    ll getValue() const {",
      "        return value;",
      "    }",
      "",
      "    mint operator+(const mint& other) const {",
      "        return mint(value + other.value, mod);",
      "    }",
      "",
      "    mint operator-(const mint& other) const {",
      "        return mint(value - other.value, mod);",
      "    }",
      "",
      "    mint operator*(const mint& other) const {",
      "        return mint(value * other.value, mod);",
      "    }",
      "",
      "    mint operator/(const mint& other) const {",
      "        return *this * other.inv();",
      "    }",
      "",
      "    bool operator==(const mint& other) const {",
      "        return value == other.value && mod == other.mod;",
      "    }",
      "",
      "    bool operator!=(const mint& other) const {",
      "        return !(*this == other);",
      "    }",
      "",
      "    mint& operator+=(const mint& other) {",
      "        value = (value + other.value) % mod;",
      "        return *this;",
      "    }",
      "",
      "    mint& operator-=(const mint& other) {",
      "        value = (value - other.value + mod) % mod;",
      "        return *this;",
      "    }",
      "",
      "    mint& operator*=(const mint& other) {",
      "        value = (value * other.value) % mod;",
      "        return *this;",
      "    }",
      "",
      "    mint& operator/=(const mint& other) {",
      "        *this *= other.inv();",
      "        return *this;",
      "    }",
      "",
      "    mint operator-() const {",
      "        return mint(-value, mod);",
      "    }",
      "",
      "    mint pow(ll exp) const {",
      "        if (exp == 0)",
      "            return mint(1, mod);",
      "        mint half = pow(exp / 2);",
      "        half *= half;",
      "        if (exp % 2 != 0)",
      "            half *= *this;",
      "        return half;",
      "    }",
      "",
      "    mint inv() const {",
      "        return mint(this->pow(mod-2).value, mod);",
      "    }",
      "};"
    ]
  },
  "cpp.aho": {
    "prefix": "cpp.aho",
    "description": "Aho-Corasick Trie and KMP",
    "body": [
      "class Trie {",
      "public:",
      "    bool terminal;",
      "    Trie *fail;",
      "    unordered_map<char, Trie*> children;",
      "",
      "    Trie() : terminal(false) {}",
      "",
      "    void insert(const char* key) {",
      "        if(*key == 0) terminal = true;",
      "        else {",
      "            if (!children[*key]) children[*key] = new Trie();",
      "            children[*key]->insert(key + 1);",
      "        }",
      "    }",
      "    void linkFail() {",
      "        Trie *root = this;",
      "        queue<Trie*> q;",
      "        q.push(root);",
      "        while(!q.empty()) {",
      "            Trie *here = q.front(); q.pop();",
      "            for(auto &child : here->children) {",
      "                Trie *there = child.second;",
      "                if(here == root) there->fail = root;",
      "                else {",
      "                    Trie *prev = here->fail;",
      "                    while(prev != root && prev->children.find(child.first) == prev->children.end()) prev = prev->fail;",
      "                    if(prev->children.find(child.first) != prev->children.end()) prev = prev->children[child.first];",
      "                    there->fail = prev;",
      "                }",
      "                if(there->fail->terminal) there->terminal = true;",
      "                q.push(there);",
      "            }",
      "        }",
      "    }",
      "};",
      "",
      "int N, Q;",
      "Trie *root = new Trie();",
      "",
      "// find substring of text in root",
      "bool kmp(Trie *root, string text) {",
      "    Trie *here = root;",
      "    for(char Capacity : text) {",
      "        while(here != root && here->children.find(Capacity) == here->children.end()) here = here->fail;",
      "        if(here->children.find(Capacity) != here->children.end()) here = here->children[Capacity];",
      "        if(here->terminal) return true;",
      "    }",
      "    return false;",
      "}",
      ""
    ]
  },
  "cpp.fenwick": {
    "prefix": "cpp.fenwick",
    "description": "Fenwick Tree",
    "body": [
      "const ll mod = 1e9+7;",
      "",
      "class FenwickTree {",
      "private:",
      "    int size;",
      "    vector<ll> tree;",
      "",
      "public:",
      "    FenwickTree(int size) : size(size) {",
      "        tree.assign(size + 1, 0);",
      "    }",
      "",
      "    // idx의 값을 +diff만큼 변화시킴 ",
      "    void update(int idx, ll diff) {",
      "        while (idx <= size) {",
      "            tree[idx] = (tree[idx] + diff) % mod;",
      "            idx += idx & -idx;",
      "        }",
      "    }",
      "",
      "    // 1 ~ idx 까지의 합",
      "    ll query(int idx) {",
      "        ll sum = 0;",
      "        while (idx > 0) {",
      "            sum = (sum + tree[idx]) % mod;",
      "            idx -= idx & -idx;",
      "        }",
      "        return sum;",
      "    }",
      "};"
    ]
  },
  "cpp.cycle": {
    "prefix": "cpp.cycle",
    "description": "check cycle in directed graph",
    "body": [
      "vector<bool> vis, rec;",
      "bool cycle(int u) {",
      "    if(!vis[u]) {",
      "        vis[u] = true;",
      "        rec[u] = true;",
      "",
      "        for(int v : g[u]) {",
      "            if(!vis[v] and cycle(v)) return true;",
      "            else if(rec[v]) return true;",
      "        }",
      "    }",
      "    rec[u] = false;",
      "    return false;",
      "}"
    ]
  }
}
